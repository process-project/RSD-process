{% extends "layout_template.html" %}
{% block title %}
  Browse All Software
{% endblock %}
{% block content %}
  <div id="overview" class="container">
    <h1 class="title">Research Software Directory</h1>
    <p class="subsubtitle">Encouraging the re-use of research software</p>
    <p id="intro_text">
      The Research Software Directory aims to promote the impact, the exchange and re-use of best practices
      and to prevent fragmentation and duplication of research software. <br/>
      Please use our tools! <a href="/more">Read more</a>
    </p>

    <div id="search_bar" class="col-1-3">
      <div class="left">
        <span>Find software</span>
      </div>
      <div class="right">
        <input type='text' v-model="filter.search" id="input" placeholder="Find software, people, organizations, technologies, etc...">
        <input type="button" id="submit" value="Search the directory">
        <!--<input type="button" @click="filter.search = ''" class="search_form" id="reset" value="reset" >-->
      </div>
    </div>

    <div id="sorter">
      <label>Sort by:</label>
      <select v-model="sort">
        <option>Last updated</option>
        <option>Bar</option>
        <option>Baz</option>
      </select>
    </div>

    <div class="col-1-3" v-cloak>
      <div class="left">
        <div id="filters">
          <label>Tags</label>
          <div v-for="tag in tags">
            <input type="checkbox" :id="tag" v-model="filter.tags" :value="tag" />
            <label :for="tag">[[tag]] <b>([[ tagCount[tag] ]])</b></label>
          </div>
        </div>
      </div>
      <div class="right">
        <div id="software_list">
          <a v-for="sw in pagedSoftware" :href="'/software/' + sw.id" :class="{ highlighted: sw.highlighted }">
            <h1 class="name">[[sw.name]]</h1>
            <div class="code">[[sw.code]]</div>
            <p class="tagline">[[sw.tagLine]]</p>
            <span class="lastUpdated">[[sw.lastUpdateAgo]]</span>
          </a>
        </div>
        <div class="pagination">
          <span @click="page = page > 1 ? page - 1 : page">
            &lt;
          </span>
          <template v-for="i in lastPage">
            <span
              v-if="showPage(i)"
              @click="page = i"
              :class="{ active: page === i }"
            >
              [[ i ]]
            </span>
            <span class="gap" v-else-if="i !== lastPage && showPage(i-1)">
              ...
            </span>
          </template>
          <span @click="page = page < lastPage ? page + 1 : page">
            &gt;
          </span>
        </div>
      </div>
    </div>
  </div>
<script type="text/javascript" src="{{url_for('static', filename='scripts/polyfills.js') }}"></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.9/vue.min.js" crossorigin="anonymous"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.9/vue.js" crossorigin="anonymous"></script>
<script>
    /*** Copyright 2013 Teun Duynstee Licensed under the Apache License, Version 2.0 ***/
    var firstBy=function(){function n(n){return n}function t(n){return"string"==typeof n?n.toLowerCase():n}function r(r,e){if(e="number"==typeof e?{direction:e}:e||{},"function"!=typeof r){var i=r;r=function(n){return n[i]?n[i]:""}}if(1===r.length){var u=r,o=e.ignoreCase?t:n;r=function(n,t){return o(u(n))<o(u(t))?-1:o(u(n))>o(u(t))?1:0}}return-1===e.direction?function(n,t){return-r(n,t)}:r}function e(n,t){var i="function"==typeof this&&this,u=r(n,t),o=i?function(n,t){return i(n,t)||u(n,t)}:u;return o.thenBy=e,o}return e}();

    Vue.config.devtools = true;
    var v = new Vue({
        el: '#overview',
        delimiters: ["[[", "]]"],
        methods: {
            log: console.log,
            showPage: function(n) {
                return n === 1 || n === this.lastPage || Math.abs(n - this.page) <= 2
            }
        },
        data: {
            tags: [
                "Visualization",
                "Image processing",
                "Machine learning",
                "Text analysis & natural language processing",
                "Real time data analysis",
                "Optimized data handling",
                "Big data",
                "Inter-operability & linked data",
                "Multi-scale & multi model simulations",
                "High performance computing",
                "GPU",
                "Workflow technologies"
            ],
            filter: {
                search: '',
                tags: [],
            },
            sort: 'Last updated',
            pageSize: 10,
            page: 1,
            software: {{ data_json }},
    },
        computed: {
            tagCount: function() {
                // initialize to 0
                var counts = this.tags.reduce(function(acc, cur) {
                    acc[cur] = 0;
                    return acc;
                }, {});
                this.software.forEach(function(sw) {
                    sw.tags.forEach(function(tag) {
                        counts[tag] += 1;
                    });
                });
                return counts;
            },
            filteredSoftware: function() {
                var self = this;
                if (self.filter.tags.length  === 0 ) {
                    return this.software;
                }
                var result = this.software.filter( function(s) {
                    var match = false;
                    s.tags.forEach(function(tag) {
                        if (self.filter.tags.includes(tag)) {
                            match = true;
                        }
                    });
                    return match;
                });
                return result
            },

            sortedSoftware: function() {
                function updatedSorter(a,b) {
                  return b.lastUpdate - a.lastUpdate;
                }
                function promoteHighlighted(a,b) {
                    if (a.highlighted && b.highlighted) return 0;
                    else if (a.highlighted) return -1;
                    else if (b.highlighted) return 1;
                    return 0;
                }
                function searchFunction(sortVal) {
                    switch (sortVal) {
                        case 'Last updated': return updatedSorter;
                        default: return updatedSorted;
                    }
                }
                if (this.sort === 'Last updated' && !this.filter.search && this.filter.tags.length === 0) {
                    return this.filteredSoftware.sort(firstBy(promoteHighlighted).thenBy(updatedSorter));
                } else {
                    return this.filteredSoftware.sort(searchFunction(this.sorts));
                }
            },

            pagedSoftware: function() {
                var offset = this.pageSize * (this.page - 1);
                return this.sortedSoftware.slice(offset, offset + this.pageSize);
            },

            lastPage: function() {
                return Math.ceil(this.filteredSoftware.length / this.pageSize);
            }
        },
        watch: {
            sort: { handler: function() { this.page = 1; } },
            filter: {
                handler: function() { this.page = 1; },
                deep: true
            }
        }
    });
</script>
{% endblock %}
